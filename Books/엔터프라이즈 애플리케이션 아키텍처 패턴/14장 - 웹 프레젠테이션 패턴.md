# 14장 - 웹 프레젠테이션 패턴

## 모델 뷰 컨트롤러

### 작동 원리

모델: 도메인에 대한 정보. UI에 직접 사용되지 않는 모든 데이터와 동작을 포함하는 비시각적인 객체
뷰: UI에서 모델을 표시하는 역할
컨트롤러: 사용자로부터 입력을 받고, 모델을 조작하며, 뷰를 적절하게 업데이트하는 역할

목적

1. 프레젠테이션을 모델로부터 분리
    * 프레젠테이션은 모델에 의존 (모델은 프레젠테이션에 의존 X)
    * 관심사를 분리하여 각 분야의 개발에 집중하도록 함
    * 모델을 시각적이지 않은 객체로 만들어주어 테스트를 용이하게 함
2. 컨트롤러를 뷰에서 분리
    * 중요도 낮음
    * 대부분의 시스템에서 사용되지 않는다.

<br>

### 사용 시점

프레젠테이션과 모델의 분리가 필요한 시스템을 구축하는 경우
모델에 실질적인 동작이 없는 아주 간단한 시스템인 경우를 제외한 모든 경우

<br>

## 페이지 컨트롤러

`모델 뷰 컨트롤러 패턴` 을 웹서비스 영역으로 확장한 개념이라고 이해
한 경로로 들어오는 요청을 처리하는 한 파일로 연결하는 방식
웹 사이트의 각 논리적 페이지 당 입력 컨트롤러 하나를 포함

### 작동 원리

웹 서버 상의 한 모듈이 웹 사이트의 각 페이지에 대한 컨트롤러 역할을 하는 것

역할

* URL 디코드 후, 작업에 필요한 데이터를 얻는다.
* 데이터를 처리하는데 필요한 모델 객체 생성, 호출
* 결과 페이지 뷰를 결정한 다음, 모델 정보를 뷰로 전달

<br>

### 사용 시점

`프런트 컨트롤러 패턴`에 비해 컨트롤러 논리가 간단한 경우

<br>

## 프런트 컨트롤러

모든 요청을 `단일 처리기 객체`로 집중하는 방법으로 요청을 통합 처리한다.
공통적인 동작을 수행하고, 데코레이터를 사용해 런타임에 수정할 수 있다.

### 작동 원리

하나의 웹 처리기(컨트롤러)로 처리를 실행할 명령을 정적으로 또는 동적으로 결정하고, 처리를 위임

정적으로 결정 시

* URL 구문 분석 후, 조건부 논리 사용
* 논리가 명시적
* 컴파일 타임에 오류 검사 가능,

동적으로 결정 시

* URL 구문 분석 후, URL에서 명시한 명령 클래스를 동적으로 인스턴스화 생성
* 웹 처리기 변경 없이, 새 명령 추가 가능

<br>

### 사용 시점

`페이지 컨트롤러 패턴` 대비 장점

* 중복 코드 분리 가능
* `데코레이터(인터셉트 필터)`를 사용해 인증, 문자인코딩, 국제화 등 추가 작업 가능
* 서버가 실행 중일 때도 데코레이터 추가 가능

<br>

## 템플릿 뷰

동적 웹 페이지를 구성 시, 정적 정보는 정적페이지와 비슷하게 작성하고, 동적 정보를 호출하는 표시자를 추가하는 것
페이지의 정적 부분은 응답을 위한 템플릿 역할을 하므로 템플릿 뷰 패턴이라고 부른다.

### 작동 원리

기본개념은 정적 HTML 페이지를 작성할 때 동적으로 변하는 내용에 표시자를 삽입하는 것이다.
아래의 방법이 있다.

* 표시자 삽입: HTML과 비슷한 태그를 사용하는 방법
* 서버 페이지 스크립트릿 이용: ASP, PHP, JSP 를 통해 프로그래밍 논리를 페이지에 추가할 수 있도록 지원하는 방식
* 도우미 객체: 스크립트릿의 프로그래밍 논리를 도우미 객체에 포함시켜, 프로그래머가 아닌 작업자도 페이지를 쉽게 편집할 수 있도록 하는 방식
* 조건부 표시: 스크립트릿 이용하여 구현가능하지만, 프로그래머가 아닌 작업자가 편집하기 힘들어진다는 단점이 여전히 존재한다. 도우미 객체를 활용할 것을 권장

예외 처리
스크립트릿에서 예외가 발생할 경우, 페이지가 반만 완성된 결과가 나오므로, 지양한다.
대신, 도우미 객체에서 예외를 잡을 수 있도록 한다.

<br>

### 사용 시점

뷰를 구현할 때, 주된 선택 사항으로 `변환 뷰`와 `템플릿 뷰`를 고려하므로 `변환 뷰`와의 비교를 기준으로 하겠다.
장점

* 페이지 구조를 보면서 페이지 내용을 구성할 수 있기 때문에, 비교적 작업하기 수월하다.

단점

* 프로그래머가 아닌 사람이 페이지를 관리하기 어려워질 수 있다.
* 변환 뷰에 비해 테스트하기가 어렵다.
* 변환 뷰에 비해 2단계 뷰를 구현하는 편이 어렵다.

<br>

## 변환 뷰

모델의 데이터를 받아 HTML을 출력하는 일종의 변환을 수행한다.

### 작동 원리

기본 개념은 도메인 기반 데이터를 받아 HTML로 변환하는 프로그램을 작성하는 것이다.
`템플릿 뷰`는 출력을 기준으로 구성되는 반면, `변환 뷰`는 입력 요소의 각 유형별 반환을 기준으로 구성된다.

* 도메인 기반 데이터로 `XML 데이터`를 준비
* 변환을 위한 논리는 `XSLT 스타일시트`에 준비
* 위 2개를 `XSLT` 엔진으로 전달하면 된다.
* `XSLT 엔진(변환기)`가 `XSLT 스타일시트`를 `입력 XML`에 적용하여 `HTML을 생성`
* `생성된 HTML` 페이지를 HTTP 응답으로 전달

<br>

### 사용 시점

뷰를 구현할 때, 주된 선택 사항으로 `변환 뷰`와 `템플릿 뷰`를 고려하므로 `템플릿 뷰`와의 비교를 기준으로 하겠다.
장점

* 거의 모든 웹 플랫폼으로 이식할 수 있다.
* XML 문서 기반의 뷰를 개발할 때 편리하다.
* `템플릿 뷰`에 비해 변환에서 HTML을 렌더링하는 작업에만 집중하게 해서 뷰에 다른 논리가 많이 포함되지 않게 만들기 쉽다.
* `템플릿 뷰`에 비해 좀 더 쉽게 테스트할 수 있다.
단점
* XLSLT는 함수형 프로그래밍 스타일과 XML 구문을 함께 사용해야하는 배우기 까다로운 언어다.

<br>

## 2단계 뷰

### 작동 원리

첫번째 변환 - 도메인 데이터를 특정한 형식 지정 없이 논리적 프레젠테이션으로 모델링한다.
두번째 변환 - 논리적 프레젠테이션 모델을 실제 필요한 형식으로 변환한다.
`변환 뷰` 이용하여 만드는 방법

* 1단계: XSLT 스타일시트를 이용하여 각 페이지가 도메인 기반 XML을 프레젠테이션 기반 XML로 변환한다.
* 2단계: XSLT 스타일시트를 이용하여 XML을 HTML로 렌더링한다.

<br>

### 사용 시점

장점

* 다중 외형 앱의 경우, 화면과 외형의 조합별로 단계 뷰 하나가 사용된다. (ex 화면10개, 외형3개를 있다면, 단일 단계 뷰 모듈 30개 필요로 한다.)
* 그러나, 2단계 뷰를 사용하면, 첫번째 단계 10개, 두번째 단계 3개로 해결가능하다.
* 화면과 외형의 수가 증가할수록 효율이 좋아진다.

단점

* 프로그래머가 렌더러를 작성해야하여 디자인을 변경할 때마다 프로그래머가 관여해야 한다.
* 다중 계층을 사용하여 프로그래밍 모델을 배우기도 어렵다.

<br>

## 애플리케이션 컨트롤러

### 작동 원리

사용자와 상호작용하며, 특정한 순서대로 화면을 노출하는 애플리케이션에서 사용된다.
현재 흐름에 맞는 화면을 보여주기 위해서 `애플리케이션 컨트롤러` 는 두가지 역할을 수행

* 실행할 도메인 논리를 결정
* 응답을 표시할 뷰를 결정

이를 위해 각 도메인 계층에서 실행할 도메인 명령과 사용할 뷰를 위한 클래스 참조의 구조화된 컬렉션 두 개를 포함한다.

<br>

### 사용 시점

* 객체의 상태에 따라 다른 뷰를 표시해야하며, 페이지를 표시하는 순서에 대한 명확한 규칙이 있을 때 유용하다.