## 아이템26 - 함수 내부의 추상화 레벨을 통일하라

```kotlin
fun makeCoffee() {
	// 계층화가 안된 상태로 나열된 코드
}
```

<br>

```kotlin
// 계층화가 된 상태의 코드
fun makeCoffee() {
	boilWater()
	brewCoffee()
	pourCoffee()
	pourMilk()
}

private fun boilWater() {

}

private fun brewCoffee() {

}

private fun pourCoffee() {

}

private fun pourMilk() {

}
```

복잡한 함수의 일부 부분을 함수로 추출해서 추상화 한 결과입니다.

#### 추상화의 장점

1. 가독성 향상

2. 재사용이 쉬워짐

   makeEspressoCoffee() 함수를 만들 때, makeCoffee() 함수에서 pourMilk() 함수 부분만 제거하면 됨.

3. 테스트가 쉬워짐

   makeCoffee() 함수 하나일 때는 큰 함수만 테스트할 수 있으나, 작은 함수들로 추출 및 추상화할 경우, 작은 함수 단위들로 테스트 가능

<br>

## 아이템27 - 변화로부터 코드를 보호하려면 추상화를 사용하라

### 리터럴을 상수로 추출 (상수 추상화)

1. 리터럴 값이 이름 및 의미를 가지게 됩니다.
2. 쉽게 변경가능합니다. 리터럴이 2번 이상 사용될 때, 일일이 변경하는 것은 번거로우나, 상수로 추출하면 쉬워집니다.

<br>

### 함수로 추출 (함수 추상화)

토스트 메세지 출력 함수, 스낵바 메세지 출력 함수 2가지를 예로 들고 있습니다.

메세지를 출력하는 표현 방식에 따라 1번 함수에서 2번 함수로 변경하는 함수의 이름을 변경하는 방법을 예시로 듭니다.

1. `.toast` 함수로 추출
2. `.snackbar` 함수로 추출

하지만, 이는 좋지 못한 추출 방법이라고 정정합니다.

근본적인 기능인 메세지 출력을 함수의 이름으로 사용하며, 출력 방법은 함수의 내부에 숨겨두는 것이 좋다고 합니다.

`.showMessage` 함수로 추출

```kotlin
fun Item26.showMessage(message: String, duration: MessageLength = MessageLength.LONG) {
        val toastDuration = when(duration) {
        MessageLength.SHORT -> 1
        MessageLength.LONG -> 3
	}

	makeToastText(message, toastDuration)
}

private fun makeToastText(message: String, toastDuration: Int) {

}
```

<br>

### 클래스로 추출 (클래스 추상화)

위에서 살펴본 함수 추상화 방식에는 한계가 있었습니다.

함수는 상태를 가질 수 없기 때문입니다.

<br>

#### 클래스의 장점

1. 상태를 가질 수 있습니다.
2. 여러 개의 함수를 가질 수 있습니다.
3. 클래스의 상태가 생성자를 통해서 주입될 수 있습니다. (또는 의존성 주입 프레임워크를 통해 클래스 생성을 위임할 수 있습니다.)
4. mock 객체를 통해 테스트할 수 있습니다.

<br>

### 인터페이스로 추출 (인터페이스 추상화)

인터페이스는 실질적인 구현을 추상화하고 (함수의 입력과 출력만 추출한 것), 사용자가 추상화된 것에만 의존하여 실질적인 구현을 할 수 있도록 합니다.

#### 인터페이스의 장점

1. 선언과 사용이 분리되어 있으므로, 실제 구현클래스를 변경할 수 있습니다.
2. 인터페이스 모킹이 클래스 모킹보다 간단하므로 테스트가 간단해집니다.

<br>

### 추상화의 단점

인터페이스 추상화처럼 구현에 자유를 주기도 하지만, 코드를 이해하고, 수정하기 어렵게 합니다.

결국, 극단적인 추상화는 득보다 실이 많아집니다.

<br>

### 추상화의 균형

많은 개발자가 참여하는 프로젝트의 경우, 객체 생성과 사용방법을 변경하기 어렵기 때문에 추상화 방법을 사용하는 것이 좋습니다. (의존성 주입 프레임워크를 사용하면, 생성 및 주입을 위임하기 때문에 간단하게 한번만 생성하면 됩니다.)

테스트를 하거나, 애플리케이션을 기반으로 새로운 애플리케이션을 만든다면, 추상화를 사용합니다.

프로젝트가 작고 실험적이라면 추상화를 하지 않고, 직접 변경합니다.

<br>

## 아이템28 - API 안정성을 확인하라

이번 장은 API를 제공할 때, 고려해야할 점을 나타냅니다.

#### 버전 관리

버전 번호를 올려 API의 안정성이 올라간 버전임을 나타냅니다.

<br>

#### @Experimental

API의 사용자에게 다소, 안정적이지 않다는 것을 알려주기 위해 사용합니다.

<br>

#### @Deprecated

API의 사용자에게 더이상 지원하지 않는 것을 알려주기 위해 사용합니다.

API 전환을 위한 유예기간을 주기 위함입니다.

<br>

## 아이템29 - 외부 API를 랩해서 사용하라

불안정한 외부 API를 사용할 때는 우리가 구현하는 비즈니스 로직과 결합하지 않도록 하는 것이 중요합니다.

외부 API가 불안정하다고 판단되면, wrap해서 사용합니다.

<br>

### 아이템30 - 요소의 가시성을 최소화하라

API 에서 공개된 요소(프로퍼티, 함수)들은 이미 외부에서 사용되고 있으므로 함부로 변경되면 코드를 사용하는 부분이 영향을 받습니다.

따라서, 초기에는 최대한 작은 API로 공개하는 것이 좋습니다.

<br>

프로퍼티가 변경되면 클래스의 상태가 보장될 수 없습니다.

따라서, 프로퍼티의 Setter는 private으로 가시성을 설정합니다.

위는 병렬프로그래밍 상황에서 동시성을 보장하는 역할을 합니다.

<br>

#### 가시성 한정자

클래스 멤버의 경우, 4개 가시성 한정자 (public, private, protected, internal)

톱레벨 요소의 경우, 3개 가시성 한정자(public, private, internal)

를 사용할 수 있습니다.

<br>

`internal`은 특정 모듈이 다른 모듈에 의해서 사용될 가능성이 있을 때, 공개하고 싶지 않은 요소를 숨기는 역할을 합니다.

그 외 한정자에 대해서는 익히 알던 내용이므로 생략하겠습니다.

DTO의 경우, 데이터를 저장하도록 설계된 클래스이기 때문에 프로퍼티의 가시성을 제한할 필요가 없다고 저자는 말하고 있습니다.