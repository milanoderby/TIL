# HMAC (Hash-based Message Authentication Code)

HMAC은 Hash-based Message Authentication Code를 의미하며, 이는 2가지의 의미를 내포합니다.

1. Hash 기반
2. MAC: 메세지 인증 코드

Hash 에 대해서는 알고 있으니 MAC에 대해서 알아보겠습니다.

<br>

### MAC

#### 정의

메세지의 **무결성**과 **인증**에 쓰이는 코드를 말합니다.

사실, 정의만 들어서는 와닿지 않는 개념입니다. 아래 메세지 인증 과정 예시를 보면서 어떻게 무결성과 인증을 보장하는지 알아보겠습니다.

<br>

#### 메세지 인증 과정

![MAC.svg](./images/HMAC-1)

<br>

송신자와 수신자는 MAC를 생성하기 위해 **MAC 알고리즘**과 **둘만 아는 Private Key**를 공유한다는 것을 전제로 합니다.

1. 송신자는 메세지를 보내기 전에, **메세지**와 약속된 **MAC 알고리즘**과 **Private Key** 값을 이용하여 **MAC**를 생성합니다. (입력: 메세지 / 함수: MAC알고리즘, Key / 출력: MAC)
2. 송신자는 메세지와 함께 MAC를 수신자에게 전송합니다.
3. 수신자는 송신자가 보낸 메세지를 검증합니다.
   1. 수신자는 송신자가 보낸 **메세지**와 약속된 **MAC 알고리즘**과 **Private Key** 값을 이용하여 **MAC**를 생성합니다. (입력: 메세지 / 함수: MAC알고리즘, Key / 출력: MAC)
   2. 송신자가 보낸 MAC값이 수신자가 생성한 MAC값과 같다면, 송신자가 보낸 메세지임(**메세지의 인증**)을 증명할 수 있습니다. (송신자가 보낸 MAC값은 **둘만 아는 Private Key**를 알고 있을 때에만 만들 수 있기 때문입니다.) 또한, 메세지가 손상되지 않았음(**메세지의 무결성**)을 보장할 수 있습니다. (기존 메세지와 전송된 메세지가 다르다면, 기존 메세지로 생성된 MAC값과 전송된 메세지로 생성된 MAC값이 달라지기 때문입니다.)

<br>

#### 주의

**MAC** 방식은 **무결성과 인증을 보장**할 수는 있지만, 여전히, 메세지 스니핑(엿들음)의 가능성은 남아있습니다. MAC은 그 자체로 메세지를 암호화하지 않기 때문입니다. 즉, 메세지의 **기밀성은 보장할 수 없습니다.**

<br>

### HMAC

다시 HMAC로 돌아오면, 이전보다 정의에 대해서 이해가 갈 것입니다.

HMAC은 쉽게 말해, **MAC**인데, MAC을 만들 때 사용하는 알고리즘으로 Hash 기반의 알고리즘을 사용하는 것임을 알 수 있습니다.

<br>

#### 보편적인 사용처

HMAC 연산을 위해 주로, SHA-2, SHA-3 등의 암호화 해시함수를 사용할 수 있습니다. (SHA-1은 보안상의 취약점이 발견되어 사용을 권장하지 않습니다.)

HMAC은 [IPsec](https://ko.wikipedia.org/wiki/IPsec), [SSH](https://ko.wikipedia.org/wiki/시큐어_셸), [TLS](https://ko.wikipedia.org/wiki/전송_계층_보안) 프로토콜, 그리고 [JSON 웹 토큰](https://ko.wikipedia.org/wiki/JSON_웹_토큰)에 사용됩니다.

<br>

#### 서버 - 클라이언트에서의 활용

서버 입장에서 신뢰하는 클라이언트에서 온 API 요청인지를 확인하기 위해 HMAC을 사용할 수 있습니다.

서버는 API의 Parameter, Header로 전송되는 **데이터 (정보보안에서의 메세지)**와 **HMAC**를 이용하여 기존에 **Private Key**와 **Hash 알고리즘**을 공유하였던 클라이언트가 맞는지를 검증할 수 있습니다.

<br>

하지만, 만약, Man in the middle (중간자)가 있어 이 요청들을 복제하여 계속해서 서버에 전송하면, 서버가 많은 요청으로 인해 장애가 발생할 수 있습니다. 이를 **replay 공격**이라고 부릅니다. 이 때, 서버의 가용성이 깨지므로 보안의 3요소를 지키지 못하게 됩니다. 이에 대한 대안으로 HMAC을 활용할 수 있습니다.

<br>

**전송하는 데이터(정보보안에서의 메세지)**에 **timestamp** 값을 추가하고, 이 데이터를 포함하여 **HMAC**으로 변환 후, 함께 서버에 전달합니다. 서버는 메세지로 전달된 **timestamp** 값과 **HMAC**을 이용해 클라이언트의 요청이 복제되지 않은 것임을 검증할 수 있고, **timestamp** 에 N초를 더한 시간내에 오는 요청만 유효한 요청이라고 판단합니다. 이를 통해 유효한 요청들만 처리한다면, MITM(중간자)의 replay 공격으로 인한 서버 마비를 방지할 수 있습니다.

<br>

### 참고자료

https://ko.wikipedia.org/wiki/HMAC

https://ko.wikipedia.org/wiki/%EB%A9%94%EC%8B%9C%EC%A7%80_%EC%9D%B8%EC%A6%9D_%EC%BD%94%EB%93%9C

https://brunch.co.kr/@sangjinkang/50
