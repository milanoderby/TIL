# Subarray Sum Equals K

### 문제 링크

https://leetcode.com/problems/subarray-sum-equals-k/

<br>

### 개념

배열 nums와 정수 k 가 주어질 때, 배열의 subarray 원소들의 합이 k를 만족하는 subarray의 개수를 구하는 문제입니다.

subarray는 기존 배열의 연속적인 원소들로 이루어진 부분 배열을 의미합니다.

<br>

### 문제풀이1 - 브루트 포스

배열의 모든 subarrray 를 구하고, 이들의 합이 k를 만족하는지 알아보는 방법의 시간복잡도는 O(N^2) 입니다.

예를 들어, 주어진 배열이 [1, 2, 3, 4, 5] 라고 가정할 때, 가능한 subarray 의 예는 다음과 같습니다.

1. `[1]` (길이 1)
2. `[2]` (길이 1)
3. `[3]` (길이 1)
4. `[4]` (길이 1)
5. `[5]` (길이 1)
6. `[1, 2]` (길이 2)
7. `[2, 3]` (길이 2)
8. `[3, 4]` (길이 2)
9. `[4, 5]` (길이 2)
10. `[1, 2, 3]` (길이 3)
11. `[2, 3, 4]` (길이 3)
12. `[3, 4, 5]` (길이 3)
13. `[1, 2, 3, 4]` (길이 4)
14. `[2, 3, 4, 5]` (길이 4)
15. `[1, 2, 3, 4, 5]` (길이 5)

<br>

원 배열의 원소의 개수가 N개일 때

subarray를 구성할 원 배열의 (시작 index, 종료 index)의 순열의 개수는 N X (N + 1) / 2 개이기 때문입니다.

그래서, 모든 가능한 subarray를 구하는 시간복잡도는 O(N^2) 이 됩니다.

문제의 조건 상 배열의 개수는 2*10^4개 이므로 이 방법으로는 해결할 수 없습니다.

<br>

### 문제풀이2 - 부분 합의 개념을 이용한 최적화

원 배열 arr의 원소의 개수가 4개일 때, 우리가 구해야 하는 subarray의 합을 아래와 같이 표로 정리해봅시다.

#### 가. subarray의 합을 표로 나타낸 것  (배열의 원소로 표현)

아래 표는 원 배열을 이용하여 만들 수 있는 모든 subarray 의 합을 의미합니다.

| 배열의 시작 및 종료index | 1                         | 2                         | 3                         | 4                         |
| ------------------------ | ------------------------- | ------------------------- | ------------------------- | ------------------------- |
| 1                        | arr[1] ~ arr[1] 까지의 합 | arr[1] ~ arr[2] 까지의 합 | arr[1] ~ arr[3] 까지의 합 | arr[1] ~ arr[4] 까지의 합 |
| 2                        |                           | arr[2] ~ arr[2] 까지의 합 | arr[2] ~ arr[3] 까지의 합 | arr[2] ~ arr[4] 까지의 합 |
| 3                        |                           |                           | arr[3] ~ arr[3] 까지의 합 | arr[3] ~ arr[4] 까지의 합 |
| 4                        |                           |                           |                           | arr[4] ~ arr[4] 까지의 합 |

여기서, 부분 합의 개념을 도입해보겠습니다.

부분 합 p[index]에 대해 아래와 같이 정의하겠습니다.

**p[index] = (arr[1] ~ arr[index] 까지의 합) / 단, p[0] = 0**

<br>

#### 나. subarray의 합을 표로 나타낸 것 (배열의 부분 합 수식으로 표현)

| 배열의 시작 및 종료index | 1           | 2           | 3           | 4           |
| ------------------------ | ----------- | ----------- | ----------- | ----------- |
| 1                        | p[1] - p[0] | p[2] - p[0] | p[3] - p[0] | p[4] - p[0] |
| 2                        |             | p[2] - p[1] | p[3] - p[1] | p[4] - p[1] |
| 3                        |             |             | p[3] - p[2] | p[4] - p[2] |
| 4                        |             |             |             | p[4] - p[3] |

<br>

위와 같이 문제를 변형하고 나서, 문제의 조건을 다시 살펴보겠습니다.

임의의 index n에 대해서 아래 수식을 만족한다는 것은

**p[n] - p[0] == k**

아래의 수식을 만족한다는 것과 동일한 의미입니다.

**p[n] - k == p[0]**

<br>

#### 다. 배열의 부분 합 수식을 이용하여 최적화

우리는 반복문을 통해서 아래와 같이 답을 찾아나갈 수 있게 됩니다.

- n = 1일 때
  - p[1] - p[0] == k 를 만족하는 p[0]가 존재하는지 찾는 조건은 p[1] - k == p[0] 가 존재하는지 찾는 조건
- n = 2일 때
  - p[2] - p[0] == k 를 만족하는 p[0]가 존재하는지 찾는 조건은 p[2] - k == p[0] 가 존재하는지 찾는 조건
  - p[2] - p[1] == k 를 만족하는 p[1]가 존재하는지 찾는 조건은 p[2] - k == p[1] 가 존재하는지 찾는 조건
- n = 3일 때
  - p[3] - p[0] == k 를 만족하는 p[0]가 존재하는지 찾는 조건은 p[3] - k == p[0] 가 존재하는지 찾는 조건
  - p[3] - p[1] == k 를 만족하는 p[1]가 존재하는지 찾는 조건은 p[3] - k == p[1] 가 존재하는지 찾는 조건
  - p[3] - p[2] == k 를 만족하는 p[2]가 존재하는지 찾는 조건은 p[3] - k == p[2] 가 존재하는지 찾는 조건
- n = 4일 때
  - p[4] - p[0] == k 를 만족하는 p[0]가 존재하는지 찾는 조건은 p[4] - k == p[0] 가 존재하는지 찾는 조건
  - p[4] - p[1] == k 를 만족하는 p[1]가 존재하는지 찾는 조건은 p[4] - k == p[1] 가 존재하는지 찾는 조건
  - p[4] - p[2] == k 를 만족하는 p[2]가 존재하는지 찾는 조건은 p[4] - k == p[2] 가 존재하는지 찾는 조건
  - p[4] - p[3] == k 를 만족하는 p[2]가 존재하는지 찾는 조건은 p[4] - k == p[3] 가 존재하는지 찾는 조건
- 즉, n을 증가시키면서, **이전에 구해놓은 부분합 p[0] ~ p[n-1] 값들** 중 **p[n] - k** 값을 가지는 숫자는 몇 개인지 찾는 문제로 변형됩니다.

<br>

### 구현

```java
public int subarraySum(int[] nums, int k) {
    Map<Integer, Integer> partSumCountMap = new HashMap<>();
    partSumCountMap.put(0, 1);
    int partSum = 0;
    int answer = 0;
    for (int i = 0; i < nums.length; i++) {
        partSum += nums[i];
        if (partSumCountMap.containsKey(partSum - k)) {
            answer += partSumCountMap.get(partSum - k);
        }

        int countOfPartSum = partSumCountMap.getOrDefault(partSum, 0);
        partSumCountMap.put(partSum, countOfPartSum + 1);
    }
    return answer;
}
```

