# 10장 - 스프링 트랜잭션 관리

### 트랜잭션, DB트랜잭션



### 동시성 트랜잭션으로 발생가능한 문제와 스프링이 지원하는 트랜잭션 격리수준

#### Dirty Read

| T1       | Field Value      | T2         | T2 Value |
| -------- | ---------------- | ---------- | -------- |
|          | 1 (기존 필드 값) |            |          |
| Update   | 2                |            |          |
|          | 2                | Read       | 2        |
| Rollback | 1                |            | 2        |
|          | 1                | Dirty Read | 2        |

위 표를 설명하자면, 아래와 같습니다.

1. T1이 Update
2. T2가 Read
3. T1이 Rollback
4. T2가 들고 있는 값이 쓰레기 값이 됨.

이를 Dirty Read 라고 합니다.

<br>

이를 해결하기 위한 트랜잭션 격리 수준으로 **READ_COMMITTED** 가 있습니다.

이는 한 트랜잭션이 commit한 필드 값에 대해서만 다른 트랜잭션이 읽을 수 있다는 것입니다.

즉, 특정 Row에 대해서 Write 시, Lock이 걸린다고 할 수 있습니다.

<br>

#### Nonrepeatable Read

| T1     | Field Value      | T2                        | T2 Value |
| ------ | ---------------- | ------------------------- | -------- |
|        | 1 (기존 필드 값) |                           |          |
|        | 1                | Read                      | 1        |
| Update | 2                |                           | 1        |
|        | 2                | Read (Nonrepeatable Read) | 2        |

위 표를 설명하자면, 아래와 같습니다.

1. T2가 Read
2. T1이 Update
3. T2가 Read (Nonrepeatable Read)
4. T2가 들고 있는 값이 이전에 읽은 값과 다르게 됨. (어떤 값을 써야될지 모르게 됨)

이를 Nonrepeatable Read 라고 합니다.

<br>

이를 해결하기 위한 트랜잭션 격리 수준으로 **REPEATABLE_READ** 가 있습니다.

이는 한 트랜잭션이 수행되는 동안 다른 트랜잭션은 해당 필드 값(로우 단위)을 수정할 수 없게하여 트랜잭션이 필드를 여러번 읽어도 동일한 값을 읽도록 보장합니다.

즉, 특정 Row에 대해서 Read 시, Lock이 걸린다고 할 수 있습니다.

<br>

#### Phantom Read

| T1         | Row Count        | T2                       | T2 Row Count |
| ---------- | ---------------- | ------------------------ | ------------ |
|            | 1 (기존 행의 수) |                          |              |
|            | 1                | Read Rows                | 1            |
| Insert Row | 2                |                          | 1            |
|            | 2                | Read Rows (Phantom Read) | 2            |

위 표를 설명하자면, 아래와 같습니다.

1. T2가 Read Rows
2. T1이 Insert Row
3. T2가 Read Rows (Phantom Read)
4. T2은 T1에서 삽입한 행이 보입니다.

이를 Phantom Read 라고 합니다.

<br>

이를 해결하기 위한 트랜잭션 격리 수준으로 **SERIALIZABLE** 이 있습니다.

이를 한 트랜잭션이 수행되는 동안 다른 트랜잭션은 로우(테이블 단위)를 수정할 수 없게하여 트랜잭션이 로우를 여러번 읽어도 동일한 행들만 읽어오도록 합니다.

즉, 특정 Table에 대해서 Read 시, Lock이 걸린다고 할 수 있습니다.

#### Lost Updates

| T1         | Field Value      | T2                        |
| ---------- | ---------------- | ------------------------- |
|            | 1 (기존 필드 값) |                           |
|            | 1                | Read                      |
| Read       | 1                |                           |
|            | 2                | Update + 1 (Lost Updates) |
| Update + 2 | 3                |                           |

위 표를 설명하자면, 아래와 같습니다.

1. T2가 Read
2. T1이 Read
3. T2가 Update
4. T1이 Update (T2가 Update한 내용이 소실됨)

이를 Lost Updates 라고 합니다.

<br>

### MySQL5, 8 격리수준



### readonly 속성이 하는 역할

