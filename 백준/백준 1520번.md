# 백준 1520번

4방향 DFS을 탐색해야됩니다. 

일반적인 DFS로 계산하면, 이미 계산이 완료된 지점로 들어오는 경로의 수까지 매번 계산을 하게 되므로 시간 초과가 됩니다.

그래서, 이미 경로 계산이 완료된 지점의 경로의 수는 메모이제이션 기법으로 저장을 해야합니다.

<br>

맨 마지막까지 가는 경로의 수를 구하기 위해 하향식 기법으로 접근합니다.

(1, 1) 지점에 도착하는 경로의 수는 1입니다.

(N, M) 지점에 도착하는 경로의 수는 (N, M) 지점 4방향 지점 중 높은 곳에서 오는 경로의 수를 모두 더한 값입니다.

DFS + DP의 코드를 구성하면 됩니다.

<br>

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {
    private static int[] dy = {0, 0, -1, 1};
    private static int[] dx = {-1, 1, 0, 0};
    private static int N, M;
    private static int[][] NUM_OF_PATH, MAP;
    private static boolean[][] isCalculated;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer tokenizer = new StringTokenizer(br.readLine());
        N = Integer.parseInt(tokenizer.nextToken());
        M = Integer.parseInt(tokenizer.nextToken());

        MAP = new int[N + 2][M + 2];
        NUM_OF_PATH = new int[N + 2][M + 2];
        isCalculated = new boolean[N + 2][M + 2];
        for (int i = 1; i <= N; i++) {
            tokenizer = new StringTokenizer(br.readLine());
            for (int j = 1; j <= M; j++) {
                MAP[i][j] = Integer.parseInt(tokenizer.nextToken());
            }
        }

        System.out.println(dfs(N, M));
    }

    private static int dfs(int y, int x) {
        if (y == 1 && x == 1) {
            isCalculated[y][x] = true;
            return 1;
        }

        if(isCalculated[y][x]) {
            return NUM_OF_PATH[y][x];
        }

        for (int dir = 0; dir < 4; dir++) {
            int ny = y + dy[dir];
            int nx = x + dx[dir];

            if (!(1 <= ny && ny <= N && 1 <= nx && nx <= M)) {
                continue;
            }

            if (MAP[y][x] < MAP[ny][nx]) {
                NUM_OF_PATH[y][x] += dfs(ny, nx);
            }
        }
        isCalculated[y][x] = true;
        return NUM_OF_PATH[y][x];
    }
}
```

