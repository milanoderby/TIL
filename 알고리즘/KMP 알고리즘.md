# KMP 알고리즘

### 사용시기

문자열 A에서 문자열 B를 찾을 때, 사용합니다.

<br>

### 단순한 문자열 패턴 검색 알고리즘

문자열 str와 str에서 찾아야할 패턴문자열은 pattern가 있다고 하겠습니다.

str = ABABBABABC

pattern = ABABC

라고 할때, 일반적인 문자열 비교 알고리즘은 다음과 같이 진행됩니다.

| 0    | 1    | 2    | 3    | 4      | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ------ | ---- | ---- | ---- | ---- | ---- |
| A    | B    | A    | B    | B      | A    | B    | A    | B    | C    |
| A    | B    | A    | B    | C      |      |      |      |      |      |
|      |      |      |      | 불일치 |      |      |      |      |      |

위와 같이 불일치하면, 다음 단계 비교는 아래와 같은 형태입니다.

| 0    | 1      | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| A    | B      | A    | B    | B    | A    | B    | A    | B    | C    |
|      | A      |      |      |      |      |      |      |      |      |
|      | 불일치 |      |      |      |      |      |      |      |      |

`i = 0, j = 0` 으로 초기화합니다.

1. str[i] 값과 pattern[i + j] 값을 비교(0<= i <= str.length()), 아래의 과정을 진행합니다. 

   - 동일한 경우, j를 반복적으로 늘려가면서, str[i + j]와 pattern[j] 값을 비교 (0<= j <= pattern.length())
     1. 위 j가 pattern.length() - 1일 때까지 동일하다면, 문자열 패턴 찾았으므로 다음 i부터 검색
     2. 중간에 하나라도 같지 않다면, 현재 반복문을탈출합니다.

   - 다를 경우, i를 1증가시킵니다.

위와 같이 `i = 0, j = 4`일 때, 불일치하면, `i = 1, j = 0` 부터 다시 탐색합니다.

이를 코드로 작성하면 다음과 같습니다.

```java
private static void findPattern(String str, String pattern) {
    List<Integer> findIndex = new ArrayList<>();
    for (int i = 0; i < str.length(); i++) {
        for (int j = 0; i + pattern.length() <= str.length(); j++) {
            if (str.charAt(i + j) != pattern.charAt(j)) {
                break;
            }

            if (j == pattern.length() - 1) {
                findIndex.add(i);
                break;
            }
        }
    }
}
```

하지만, 위와 같은 알고리즘은 

a의 문자열 길이 = N, b의 문자열 길이 = M 이라고 가정할 때, O(N * M) 시간복잡도를 가집니다.

이보다 더 효율적인 알고리즘이 있습니다.

<br>

### KMP 알고리즘 설명

KMP의 아이디어는 `이미 탐색한 부분을 다시 탐색하지 않겠다` 는 것입니다.

이 아이디어를 이해하기 위해 위의 예제를 다시 생각해보겠습니다.

str = ABABBABABC

pattern = ABABC

라고 할때, 

| 0    | 1    | 2    | 3    | 4      | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ------ | ---- | ---- | ---- | ---- | ---- |
| A    | B    | A    | B    | B      | A    | B    | A    | B    | C    |
| A    | B    | A    | B    | C      |      |      |      |      |      |
|      |      |      |      | 불일치 |      |      |      |      |      |

1. i를 1씩 늘려가면서, A[i] 값과 B[0] 값을 비교(0<= i <= A.length())
   1. 동일한 i를 찾으면, j를 반복적으로 늘려가면서, A[i + j]와 B[j] 값을 비교 (0<= j <= B.length())
   2. 위 j가 B.length() - 1일 때까지 동일하다면, 문자열 패턴찾기 완료
   3. 중간에 하나라도 같지 않다면, A[i + 1]과 B[0] 값부터 다시 비교

위와 같이 `i = 0, j = 4`일 때, 불일치하면, `i = 1, j = 0` 부터 다시 탐색했었습니다.

<br>

하지만, 위 과정에서 3번과정을 조금 효율적으로 바꾸겠다는 것입니다.

왜냐하면, 우리는 A[1]과 B[0]이 다르다는 것을 이미 알 수 있기 때문입니다.

| 0    | 1      | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| A    | B      | A    | B    | B    | A    | B    | A    | B    | C    |
|      | A      | B    | A    | B    |      |      |      |      |      |
|      | 불일치 |      |      |      |      |      |      |      |      |

즉, 다음 비교의 형태는 위의 형태가 아니라 아래와 같아야한다는 것을 알 수 있습니다.

| 0    | 1    | 2    | 3    | 4      | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ------ | ---- | ---- | ---- | ---- | ---- |
| A    | B    | A    | B    | B      | A    | B    | A    | B    | C    |
|      |      | A    | B    | A      |      |      |      |      |      |
|      |      |      |      | 불일치 |      |      |      |      |      |

<br>

위와 같이 건너뛰기 위해 우리는 이미 알고 있는 비교가 완료된 문자열의 정보를 이용합니다.

즉, 비교가 완료된 `ABAB` 는 이미 동일함이 확인된 문자열입니다.  이 정보를 이용하여 이미 동일함이 확인된 `AB` 구간은 건너뛰는 개념입니다.

### PI 배열

위의 `AB`는 어떻게 찾느냐? 답은 `접두사와 접미사가 동일한 최대구간` 입니다.

우리는 `ABAB` 의 문자열에서 `접두사와 접미사가 동일한 최대구간` 의 비교를 건너뛰는 것입니다.

###### KMP 알고리즘에서는 찾고자하는 패턴문자열의 PI 배열을 사용합니다. 즉, 여기서는 B의 패턴문자열을 찾는 것입니다.

위를 구하기 위해 pi[] 배열을 만들고, pi[i]에 각 `B[0] ~ B[i] 까지 부분문자열의 각 부분에서 접두사와 접미사가 같은 부분의 개수`를 저장합니다.

| i    | 부분문자열 | pi[i] |
| ---- | ---------- | ----- |
| 0    | A          | 0     |
| 1    | AB         | 0     |
| 2    | ABA        | 1     |
| 3    | ABAB       | 2     |
| 4    | ABABC      | 0     |

위와 pi[] 배열을 구하기위해 다음의 과정을 거칩니다.

pi 배열의 의미를 위해 pi[0] = 0 이기 때문에, i = 1부터 시행합니다.

1. i를 1씩 늘려가면서, B[i + j]와 B[j] 값을 비교(0<= i + j < B.length())
   1. 값이 같을 때, pi 배열 값을 갱신하고,  j의 값을 늘려줍니다. (`pi[i + j] = j + 1`, `j++`)
   2. 값이 다를 때,
      1. j > 0 인 경우, `j = pi[j - 1];`, `j = pi[j - 1]` 를 시행합니다. (현재, B[i + j] 와 `B의 접두사와 접미사가 동일한 문자열`의 마지막 문자를 비교하기 위함입니다.)
      2. j == 0 인 경우, 비교 중인 `문자열 B의 접두사와 접미사가 동일한 구간` 이 없다는 뜻이므로 i의 값을 증가시킵니다.(`i++`)

<br>

`i=1, j=0` 일 때

| 0    | 1      | 2    | 3    | 4    |
| ---- | ------ | ---- | ---- | ---- |
| A    | B      | A    | B    | C    |
|      | A      |      |      |      |
|      | 불일치 |      |      |      |

pi[1] = 0 `(A[1+0] 과 B[0]이 불일치하므로 pi[0] 은 갱신되지 않는 초기의 0값을 그대로 가집니다.)`

`i=2, j=0` 일 때

| 0    | 1    | 2    | 3    | 4      |
| ---- | ---- | ---- | ---- | ------ |
| A    | B    | A    | B    | B      |
|      |      | A    | B    | A      |
|      |      |      |      | 불일치 |

pi[2] = 1 (`pi[i + j] = j + 1` 에 의해)

pi[3] = 2 (`pi[i + j] = j + 1` 에 의해)

<br>

위의 작업까지 비교를 하고나면, `i=2, j=2`가 되어있고, `A[i+j]` 와 `B[j]` 가 비교가 된 상태입니다. 

여기서, 더 빠르게 `pi[4]` 를 구하기 위해서는, 다음 비교를 `ABABB`와 이미 비교가 완료된 문자열 `AB`의 `접두사와 접미사가 동일한 최대일 때, 문자열` 과 비교를 건너뛰어야합니다.

즉, 아래의 형태로 비교를 한번더 해야됩니다.

이를 위해 `i += (j - pi[j - 1])`, `j = pi[j - 1]`를 차례로 대입해줍니다.

| 0    | 1    | 2    | 3    | 4      |
| ---- | ---- | ---- | ---- | ------ |
| A    | B    | A    | B    | B      |
|      |      |      |      | A      |
|      |      |      |      | 불일치 |

pi[4] = 0 `(A[4 + 0] 과 B[0]이 불일치하므로 pi[4] 은 갱신되지 않는 초기의 0값을 그대로 가집니다.)`

<br>

이를 코드로 하면, 다음과 같습니다.

```java
private static int[] getPiArray(String str) {
    int[] pi = new int[str.length()];
    for (int i = 1, j = 0; i + j < str.length(); ) {
        if (str.charAt(i + j) == str.charAt(j)) {
            pi[i + j] = j + 1;
            j++;
        } else {
            if (j > 0) {
                i += j - pi[j - 1];
                j = pi[j - 1];
            } else {
                i++;
            }
        }
    }
    return pi;
}
```

### KMP 알고리즘을 이용하여 패턴찾기

문자열 str와 str에서 찾아야할 패턴문자열은 pattern가 있다고 하겠습니다.

str = ABABBABABC

pattern = ABABC

먼저, 찾아야할 패턴문자열 pattern의 PI배열을 구합니다.

<br>

그 후, str에서 pattern를 찾기 위한 KMP 알고리즘을 시행합니다.

`i = 0, j = 0` 부터 시작합니다.

1. str[i + j]와 pattern[j] 값을 비교, i (0<= i + j < .length())

   1. 값이 같을 때, j의 값을 증가시킵니다.

      1. pattern을 찾았다면, 다음 패턴 검색을 위해 비교완료된 문자열의 `접두사와 접미사가 동일한 구간`을 넘깁니다.

         ```java
         i += j - pi[j - 1];
         j = pi[j - 1];
         ```

   2. 값이 다를 때,

      1. j > 0 인 경우, 다음 패턴 검색을 위해 비교완료된 문자열의 `접두사와 접미사가 동일한 구간`을 넘깁니다.

         ```java
         i += j - pi[j - 1];
         j = pi[j - 1];
         ```

      2. j == 0 인 경우, 비교 중인 `문자열 B의 접두사와 접미사가 동일한 구간` 이 없다는 뜻이므로 i의 값을 증가시킵니다.(`i++`)

이를 코드로 구현하면 다음과 같습니다.

```java
private static void findPattern(String str, String pattern, int[] pi) {
	List<Integer> answer = new ArrayList<>();
	for (int i = 0, j = 0; i + pattern.length() <= str.length(); ) {
		if (str.charAt(i + j) == pattern.charAt(j)) {
			j++;
			if (j >= pattern.length()) {
				answer.add(i + 1);
				i += j - pi[j - 1];
				j = pi[j - 1];
			}
		} else {
			if (j > 0) {
				i += j - pi[j - 1];
				j = pi[j - 1];
			} else {
				i++;
			}
		}
	}
}
```

